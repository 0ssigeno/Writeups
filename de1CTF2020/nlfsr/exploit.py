#!/usr/bin/env python3

from multiprocessing import Process, Manager

n4 = 6
n3 = 13
n2 = 19
n1 = 19


def lfsr(r, m):
    output = ((r << 1) & 0xffffff) ^ (bin(r & m).count('1') % 2)
    last_bit = (bin(r & m).count('1') % 2)
    return output, last_bit


def combine(ao, bo, co, do):
    return (ao * bo) ^ (bo * co) ^ (bo * do) ^ co ^ do


def chunkIt(seq, num):
    avg = len(seq) / float(num)
    out = []
    last = 0.0

    while last < len(seq):
        out.append(seq[int(last):int(last + avg)])
        last += avg

    return out


def start_one(maps: {}, find, a=None, b=None, c=None, d=None, statistic=False):
    res = "Testing"
    if a is not None:
        res += " a " + str(a)
    if b is not None:
        res += " b " + str(b)
    if c is not None:
        res += " c " + str(c)
    if d is not None:
        res += " d " + str(d)
    res += "\nFinding " + find
    # print(res)
    thread = 4
    num = 300
    data = open('./data').read(num)
    if find == "a":
        ansn = range(pow(2, n1 - 1), pow(2, n1))
    elif find == "b":
        ansn = range(pow(2, n2 - 1), pow(2, n2))
    elif find == "c":
        ansn = range(pow(2, n3 - 1), pow(2, n3))
    elif find == "d":
        ansn = range(pow(2, n4 - 1), pow(2, n4))
    else:
        raise
    ranges = chunkIt(ansn, thread)
    manager = Manager()
    return_list = manager.list()
    ps = []
    for i in range(thread):
        ps.append(Process(target=guessOne, args=(maps, ranges[i], a, b, c, d, find, statistic, data, return_list)))
    for p in ps:
        p.start()
    for p in ps:
        p.join()
    return return_list


def guessOne(maps: {}, rang, a, b, c, d, find, statistic, data, res):
    ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31
    old_a = a
    old_b = b
    old_c = c
    old_d = d
    for var in rang:
        a = old_a
        b = old_b
        c = old_c
        d = old_d
        if find == "a":
            a = var
        elif find == "b":
            b = var
        elif find == "c":
            c = var
        elif find == "d":
            d = var
        else:
            raise
        good = 0
        total = 0
        flag = True
        for j in range(0, len(data)):
            to_check = ()
            output = int(data[j])
            if a is not None:
                a, a_bit = lfsr(a, ma)
                to_check += (a_bit, )
                # to_check = (0, )
            if b is not None:
                b, b_bit = lfsr(b, mb)
                to_check += (b_bit, )
                # to_check = (0, 1)
            if c is not None:
                c, c_bit = lfsr(c, mc)
                to_check += (c_bit,)
            if d is not None:
                d, d_bit = lfsr(d, md)
                to_check += (d_bit,)

            expected_res = maps.get(to_check, None)
            if expected_res is None:
                continue
            if statistic:
                if expected_res == output:
                    good += 1
                total += 1
            else:
                if expected_res != output:
                    flag = False
        if statistic:
            if total != 0:
                ratio = good * 100 / total
                if ratio >= 70:
                    res.append(var)
        else:
            if flag:
                res.append(var)

    return sorted(res, reverse=True)


mapA = {
    (0,): 0
}

mapAB = {
    (0, 1): 0,
    (1, 1): 1
}

mapABC = {
    (0, 1, 0): 0,
    (0, 1, 1): 0,
    (1, 1, 0): 1,
    (1, 1, 1): 1
}
mapABCD = {
    (0, 0, 0, 0): 0,
    (0, 0, 0, 1): 1,
    (0, 0, 1, 0): 1,
    (0, 0, 1, 1): 0,
    (0, 1, 0, 0): 0,
    (0, 1, 0, 1): 0,
    (0, 1, 1, 0): 0,
    (0, 1, 1, 1): 0,
    (1, 0, 0, 0): 0,
    (1, 0, 0, 1): 1,
    (1, 0, 1, 0): 1,
    (1, 0, 1, 1): 0,
    (1, 1, 0, 0): 1,
    (1, 1, 0, 1): 1,
    (1, 1, 1, 0): 1,
    (1, 1, 1, 1): 1,
}

R1 = start_one(mapA, find="a", statistic=True)
if R1:
    print("A: " + " ".join([str(a) for a in R1]))
    for a in R1:
        R2 = start_one(mapAB, find="b", a=a, statistic=False)
        print(R2)
        if R2:
            for b in R2:
                for d in range(32, 64):
                    R3 = start_one(mapABCD, find="c", a=a, b=b, d=d, statistic=False)
                    print(d, R3)
